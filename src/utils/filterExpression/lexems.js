// filterExpression/lexems.js
// LayerRenamer
//
// created by Leonard Pauli, jun 2018
// copyright © Leonard Pauli 2018
//
// based on rim / towards rim

import {log} from 'string-from-object'
const concat = xxs=> xxs.reduce((a, xs)=> (a.push(...xs), a), [])


// Philosofy:
// 	- expressions should always parse, syntax errors reported back + skipped gracefully, warnings auto fixed (+ reported back)
// 	- parsed code should always be evaluatable


// lexems flags

export const flags = {
	autoInsertIfNeeded: true, // if no other paths are valid, insert token even if it didn't exist, useful for eg. autoclose
	optional: true,
	repeat: true, // is one or more (+) by default, combine repeat + optional to get 0 or more (*)
	usingOr: true,
}

const {autoInsertIfNeeded, optional, repeat, usingOr} = flags


// lexems example
const keysMeta = 'name,description'.split(',')
const keysMatch = 'regex,retain,lexems,usingOr'.split(',')
const keysTokenizerReserved = 'matched,tokens,match'.split(',')
const keysReserved = concat([keysMeta, keysMatch, keysTokenizerReserved, Object.keys(flags)])

/*
const lexem = {}
const lexemMatch = {
	regex: /^((g1)|(g2))/,
	retain: true, // true (all), n (retain n chars), -n (retain match.length-n chars), false | 0 (retain no chars)
} || {
	...{usingOr: true}||{lexemsModeAnd: false}, // match one of them || match all of them after each other (default)
	lexems: [lexem, lexem, ...lexem],
}
const lexemBase = {
	name: '...', // autogenerated from lexems tree structure, eg. text.expr.open
	description: 'what this lexem is...',
	someSubLexem: lexem,
}
const lexemExample = { ...lexemBase, ...lexemMatch, ...flags }
*/

// lexems definition

export const root = {
	paren: {
		open: {regex: /^\(/},
		close: {regex: /^\)/},
	},
	num: {regex: /^[1-9][0-9]*(\.[0-9]+)?/, description: 'number'},
	spv: {regex: /^[\t ]+/, description: 'space-vertical (optional for formatting / min 1 req for separation / elastic tab for alignment)'},
	spvo: {},
	expr: {
		description: 'expression',
		single: {usingOr},
	},
	text: {
		open: {regex: /^"/},
		close: {regex: /^"/},
		raw: {regex: /^(([^\\"]|\\[\\"])*)/},
		expr: {
			open: {regex: /^\\\(/, retain: -1},
		},
		inner: {},
	},
	dot: {regex: /^\./},
	comma: {regex: /^,/},
	id: {
		regex: /^[^ .(){}[\]\n"]/,
		strip: {usingOr},
		special: {
			regex: /^[-<>=+*/!,]+/, // !%&\/=?^*<>@$§|≈±~–,≤≥•‰≠·
		},
	},
}
const {paren, spv, num, expr, text, id, dot, comma, spvo} = root
root.lexems = [expr]

Object.assign(spvo, spv, {optional})

text.expr.lexems = [text.expr.open, expr]
text.inner.lexems = [{repeat, optional, usingOr, lexems: [text.raw, text.expr]}]
text.lexems = [text.open, text.inner, {...text.close, autoInsertIfNeeded}]

id.strip.lexems = [id, {lexems: [{...id, optional}, // abc, .a."b".("b"+c)
	{lexems: [dot, {usingOr, lexems: [id, text, paren]}], optional, repeat}]}]

paren.lexems = [paren.open, spvo, expr, spvo, [paren.close, {autoInsertIfNeeded}]]
// expr.commalist.lexems = [expr, {optional, repeat, lexems: [comma, spvo, expr]}]
expr.single.lexems = [
	num,
	text,
	paren,
	id.strip,
	id.special,
]
expr.lexems = [expr.single, {repeat, optional, usingOr, lexems: [spvo, expr.single]}]



// process lexems
const process = (lexem, k, parent=null)=> {
	// process meta
	lexem.name = lexem.name || (parent && parent.name+'.' || '')+k

	// validate matcher + set defaults
	if (lexem.regex) {
		if (!(lexem.regex instanceof RegExp)) throw new Error(
			`lexem(${lexem.name}).regex (should be) instanceof RegExp (was ${lexem.regex})`)
		lexem.retain = lexem.retain === void 0? true: lexem.retain===false? 0: lexem.retain
	} else if (lexem.lexems) {
		if (!Array.isArray(lexem.lexems)) throw new Error(
			`lexem(${lexem.name}).lexems has to be array`)
		lexem.usingOr = lexem.usingOr || false
	} else throw new Error(
		`lexem(${lexem.name}) has to have a matcher (.regex/.lexems/.or)`)

	// process children
	const keysChildren = Object.keys(lexem).filter(k=> !keysReserved.includes(k))
	keysChildren.forEach(k=> process(lexem[k], k, lexem))
}
process(root, '')

// log(root)

export default root

/* Notes
§1234567890+´¨'-.,<
°!"#€%&/()=?`^*_:;>
¶©@£$∞§|[]≈±´~™–…‚≤
•¡”¥¢‰¶\{}≠¿`^’—·„≥
•Ω®†ıπ˙ß∂ƒ¸˛√ªﬁøæ÷≈‹›‘’°˜ˆ∏˚◊∫¯˘¬º«»”

<>≤≥
'"„”`´’‘«»‹›
§1234567890
±+-/=≈^*~√÷≈≠
,‚:;
#‰%&|
!?¡¿
¶@§–…
¶—•·
©™®†ı¸˛
°˜ˆ˘˚˙¨¯
∞Ω¥¢£$€
πß∂ƒªﬁøæ
∏◊∫¬º

()[]{}\\
*/
